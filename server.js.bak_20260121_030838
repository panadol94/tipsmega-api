require("dotenv").config();

const express = require("express");
const cors = require("cors");
const admin = require("firebase-admin");
const TelegramBot = require("node-telegram-bot-api");
const axios = require("axios");
const { Storage } = require("@google-cloud/storage");
const fs = require("fs");
const path = require("path");
const os = require("os");
const crypto = require("crypto");

const app = express();
app.use(cors());
app.use(express.json());

// ===== ENV =====
const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const GROUP_USER_JOIN = process.env.TG_GROUP_USER_JOIN; // -100...
const GROUP_ADMIN_REPORT = process.env.TG_GROUP_ADMIN_REPORT; // -100...
const ADMIN_GROUP_ID = process.env.ADMIN_GROUP_ID || GROUP_ADMIN_REPORT;
const GCS_BUCKET = process.env.GCS_BUCKET_NAME;
const ADMIN_SECRET = process.env.ADMIN_SECRET || "";
const AUTH_SECRET = process.env.AUTH_SECRET || process.env.ADMIN_SECRET || "CHANGE_ME_AUTH_SECRET";

// Public info
const GROUP_LINK = "https://t.me/tipsmega888chat";
const BOT_USERNAME = "@TIPSMEGA888OTPBOT";
const OTP_TTL_MS = 3 * 60 * 1000; // 3 min

// ===== INIT FIREBASE =====
admin.initializeApp();
const db = admin.firestore();

// ===== INIT GCS =====
const storage = new Storage();
const bucket = storage.bucket(GCS_BUCKET);

// ===== INIT TELEGRAM BOT (WEBHOOK MODE) =====
const bot = new TelegramBot(BOT_TOKEN, { webHook: true });

// ===== WIZARD STATE =====
const companyWizard = {}; // { tgUserId: { step, data } }

// ===== HELPERS =====
function generateOTP() {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

function nowMs() {
  return Date.now();
}

function normalizePhone(input) {
  const raw = String(input || "").trim();
  const cleaned = raw.replace(/[^\d+]/g, "");
  // require + and 8..15 digits total (loose E.164)
  if (!cleaned.startsWith("+")) return null;
  const digits = cleaned.replace(/\D/g, "");
  if (digits.length < 8 || digits.length > 15) return null;
  return "+" + digits;
}

function hashOTP(otp) {
  return crypto.createHmac("sha256", AUTH_SECRET).update(String(otp)).digest("hex");
}

function passwordHash(password, salt) {
  return crypto.scryptSync(String(password), salt, 32).toString("hex");
}

function makeSalt() {
  return crypto.randomBytes(16).toString("hex");
}

function signToken(payloadObj) {
  const payload = Buffer.from(JSON.stringify(payloadObj), "utf8").toString("base64url");
  const sig = crypto.createHmac("sha256", AUTH_SECRET).update(payload).digest("base64url");
  return `${payload}.${sig}`;
}

function verifyToken(token) {
  try {
    const parts = String(token || "").split(".");
    if (parts.length !== 2) return null;
    const [payload, sig] = parts;
    const expected = crypto.createHmac("sha256", AUTH_SECRET).update(payload).digest("base64url");
    if (sig !== expected) return null;
    const obj = JSON.parse(Buffer.from(payload, "base64url").toString("utf8"));
    return obj || null;
  } catch {
    return null;
  }
}

async function isAdmin(tgUserId) {
  // (A) Manual admin list in Firestore (admins/{tgUserId})
  try {
    const snap = await db.collection("admins").doc(String(tgUserId)).get();
    if (snap.exists) return true;
  } catch (e) {}

  // (B) Telegram group admin/creator (ADMIN_GROUP_ID / TG_GROUP_ADMIN_REPORT)
  try {
    const gid = ADMIN_GROUP_ID;
    if (!gid) return false;
    const member = await bot.getChatMember(gid, tgUserId);
    return ["administrator", "creator"].includes(member.status);
  } catch (e) {
    return false;
  }
}


async function ensureJoinedGroup(userId) {
  try {
    const member = await bot.getChatMember(GROUP_USER_JOIN, userId);
    return ["member", "administrator", "creator"].includes(member.status);
  } catch {
    return false;
  }
}

// find tg user by phone (saved when user share contact in bot)
async function findTelegramUserByPhone(phoneE164) {
  const qsnap = await db.collection("tg_users").where("phone", "==", phoneE164).limit(1).get();
  if (qsnap.empty) return null;
  const d = qsnap.docs[0].data() || {};
  // IMPORTANT: tgUserId should exist (we save doc id as tgUserId in your bot flow)
  const tgUserId = qsnap.docs[0].id;
  return { tgUserId, data: d };
}

// ===== SETTINGS =====
async function getApprovalMode() {
  const ref = db.collection("settings").doc("approval");
  const snap = await ref.get();
  if (!snap.exists) {
    await ref.set({
      mode: "AUTO",
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    });
    return "AUTO";
  }
  return snap.data()?.mode || "AUTO";
}

// ===== TELEGRAM WEBHOOK ENDPOINT =====
app.post("/telegram/webhook", (req, res) => {
  bot.processUpdate(req.body);
  res.sendStatus(200);
});

// ===== GROUP WELCOME MESSAGE =====
bot.on("new_chat_members", (msg) => {
  const chatId = msg.chat.id;
  bot.sendMessage(
    chatId,
    `ðŸ‘‹ Selamat datang ke TipsMega888!
Untuk dapat:
âœ… OTP
â­ Bonus kredit scan
ðŸ” Akaun VERIFIED
Sila:
1ï¸âƒ£ PM bot ${BOT_USERNAME}
2ï¸âƒ£ Tekan /start
3ï¸âƒ£ Share contact bila diminta`
  );
});

// ===== BOT: START =====
bot.onText(/\/start/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  const joined = await ensureJoinedGroup(userId);
  if (!joined) {
    return bot.sendMessage(
      chatId,
      `âŒ Sila join group dahulu:\n${GROUP_LINK}`
    );
  }

  bot.sendMessage(chatId, "Sila tekan butang di bawah untuk kongsi contact:", {
    reply_markup: {
      keyboard: [[{ text: "ðŸ“± Share Contact", request_contact: true }]],
      resize_keyboard: true,
      one_time_keyboard: true,
    },
  });
});

// ===== BOT: CONTACT SHARE -> OTP (existing) =====
bot.on("contact", async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  // normalize phone to +E164
  const phoneRaw = msg.contact?.phone_number || "";
  const phone = normalizePhone(phoneRaw.startsWith("+") ? phoneRaw : `+${phoneRaw.replace(/\D/g, "")}`) || phoneRaw;

  const joined = await ensureJoinedGroup(userId);
  if (!joined) {
    return bot.sendMessage(chatId, `âŒ Anda belum join group. Sila join dahulu:\n${GROUP_LINK}`);
  }

  const otp = generateOTP();
  const mode = await getApprovalMode();

  await db.collection("otp_requests").doc(String(userId)).set({
    tgUserId: userId,
    phone,
    otp,
    status: mode === "AUTO" ? "APPROVED" : "PENDING",
    createdAt: admin.firestore.FieldValue.serverTimestamp(),
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
  });

  // save tg user mapping
  await db.collection("tg_users").doc(String(userId)).set(
    {
      phone,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    },
    { merge: true }
  );

  await bot.sendMessage(
    GROUP_ADMIN_REPORT,
    `ðŸ“© OTP Request\nUserID: ${userId}\nPhone: ${phone}\nOTP: ${otp}\nMode: ${mode}`
  );

  if (mode === "AUTO") {
    await db.collection("tg_users").doc(String(userId)).set(
      {
        phone,
        verified: true,
        stars: admin.firestore.FieldValue.increment(10),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      },
      { merge: true }
    );

    return bot.sendMessage(
      chatId,
      `âœ… Verified!\nOTP anda: *${otp}*\nBonus â­10 telah ditambah.`,
      { parse_mode: "Markdown" }
    );
  }

  return bot.sendMessage(chatId, "â³ Permintaan dihantar. Sila tunggu approval admin.");
});

// ===== ADMIN: MODE SWITCH =====
bot.onText(/\/autoapprove/, async (msg) => {
  const userId = msg.from.id;
  if (!(await isAdmin(userId))) return;
  await db.collection("settings").doc("approval").set({
    mode: "AUTO",
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    updatedBy: userId,
  });
  bot.sendMessage(msg.chat.id, "âœ… Mode set ke AUTO APPROVE");
});

bot.onText(/\/manualapprove/, async (msg) => {
  const userId = msg.from.id;
  if (!(await isAdmin(userId))) return;
  await db.collection("settings").doc("approval").set({
    mode: "MANUAL",
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    updatedBy: userId,
  });
  bot.sendMessage(msg.chat.id, "â³ Mode set ke MANUAL APPROVE");
});

bot.onText(/\/mode/, async (msg) => {
  const mode = await getApprovalMode();
  bot.sendMessage(msg.chat.id, `Current approval mode: ${mode}`);
});

// =======================
// COMPANY WIZARD (ADMIN)
// =======================
bot.onText(/\/addcompany/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  const ok = await isAdmin(userId);
  if (!ok) {
    return bot.sendMessage(
      chatId,
      "? Anda bukan admin.\n\nSemak:\n1) Firestore: admins/{userId}\n2) ADMIN_GROUP_ID env betul\n\nUserId anda: " + userId
    );
  }

  companyWizard[userId] = { step: 1, data: {} };
  return bot.sendMessage(chatId, "?? Step 1: Hantar *nama company*", { parse_mode: "Markdown" });
});
bot.onText(/\/listcompany/, async (msg) => {
  const snap = await db.collection("companies").get();
  if (snap.empty) return bot.sendMessage(msg.chat.id, "Tiada company lagi.");
  let text = "ðŸ“‹ Company List:\n";
  snap.forEach((d) => {
    const c = d.data();
    text += `- ${c.name}\n`;
  });
  bot.sendMessage(msg.chat.id, text);
});

bot.onText(/\/delcompany (.+)/, async (msg, match) => {
  const userId = msg.from.id;
  if (!(await isAdmin(userId))) return;
  const name = (match[1] || "").trim();
  if (!name) return;
  await db.collection("companies").doc(name).delete();
  bot.sendMessage(msg.chat.id, `âŒ Company *${name}* telah dipadam.`, { parse_mode: "Markdown" });
});

// Wizard steps handler
bot.on("message", async (msg) => {
  const userId = msg.from?.id;
  const chatId = msg.chat?.id;
  if (!userId || !chatId) return;
  if (!companyWizard[userId]) return;
  if (!(await isAdmin(userId))) return;

  const wizard = companyWizard[userId];

  if (wizard.step === 1 && msg.text) {
    wizard.data.name = msg.text.trim();
    wizard.step = 2;
    return bot.sendMessage(chatId, "ðŸ”— Step 2: Hantar *link* (atau taip `SKIP`)", { parse_mode: "Markdown" });
  }

  if (wizard.step === 2 && msg.text) {
    wizard.data.link = msg.text.trim().toUpperCase() === "SKIP" ? "" : msg.text.trim();
    wizard.step = 3;
    return bot.sendMessage(chatId, "ðŸ“ Step 3: Hantar *caption* (atau taip `SKIP`)", { parse_mode: "Markdown" });
  }

  if (wizard.step === 3 && msg.text) {
    wizard.data.caption = msg.text.trim().toUpperCase() === "SKIP" ? "" : msg.text.trim();
    wizard.step = 4;
    return bot.sendMessage(chatId, "ðŸ“· Step 4: Hantar *gambar atau video* untuk company ini");
  }

  if (wizard.step === 4 && (msg.photo || msg.video)) {
    try {
      let fileId, mediaType, ext;
      if (msg.photo) {
        fileId = msg.photo[msg.photo.length - 1].file_id;
        mediaType = "photo";
        ext = "jpg";
      } else {
        fileId = msg.video.file_id;
        mediaType = "video";
        ext = "mp4";
      }

      const file = await bot.getFile(fileId);
      const url = `https://api.telegram.org/file/bot${BOT_TOKEN}/${file.file_path}`;
      const tempPath = path.join(os.tmpdir(), `${Date.now()}.${ext}`);

      const writer = fs.createWriteStream(tempPath);
      const response = await axios({ url, method: "GET", responseType: "stream" });
      response.data.pipe(writer);

      await new Promise((resolve, reject) => {
        writer.on("finish", resolve);
        writer.on("error", reject);
      });

      const safeName = String(wizard.data.name || "company").replace(/[^\w\- ]+/g, "").trim() || "company";
      const gcsPath = `companies/${safeName}/${Date.now()}.${ext}`;

      await bucket.upload(tempPath, {
        destination: gcsPath,
        public: true,
        metadata: { cacheControl: "public, max-age=31536000" },
      });

      fs.unlinkSync(tempPath);

      const storageUrl = `https://storage.googleapis.com/${GCS_BUCKET}/${gcsPath}`;

      await db.collection("companies").doc(safeName).set({
        name: safeName,
        link: wizard.data.link || "",
        caption: wizard.data.caption || "",
        status: "ACTIVE",
        mediaType,
        storageUrl,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      delete companyWizard[userId];
      return bot.sendMessage(chatId, `âœ… Company *${safeName}* telah LIVE di website!`, { parse_mode: "Markdown" });
    } catch (e) {
      delete companyWizard[userId];
      return bot.sendMessage(chatId, "âŒ Upload gagal. Cuba /addcompany semula.");
    }
  }
});

// =======================
// DEBUG: FIRESTORE CHECK
// =======================
app.get("/api/_debug/firestore", async (_req, res) => {
  try {
    const at = admin.firestore.Timestamp.now();
    res.json({ ok: true, data: { at } });
  } catch (e) {
    res.status(500).json({ ok: false, error: String(e?.message || e) });
  }
});

// =======================
// API: INIT DEVICE (free 1 star first time)
// =======================
app.post("/api/init", async (req, res) => {
  try {
    const { deviceId } = req.body || {};
    if (!deviceId) return res.status(400).json({ error: "missing deviceId" });

    const ref = db.collection("devices").doc(String(deviceId));
    const snap = await ref.get();

    if (!snap.exists) {
      await ref.set({
        deviceId,
        stars: 1,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      });
      return res.json({ deviceId, stars: 1, isNew: true });
    }

    const data = snap.data() || {};
    return res.json({ deviceId, stars: data.stars ?? 0, isNew: false });
  } catch (e) {
    return res.status(500).json({ error: "Init failed", detail: String(e?.message || e) });
  }
});

// =======================
// API: SCAN (deduct 1 star)
// =======================
app.post("/api/scan", async (req, res) => {
  try {
    const { deviceId, megaId } = req.body || {};
    if (!deviceId) return res.status(400).json({ error: "missing deviceId" });
    if (!megaId) return res.status(400).json({ error: "missing megaId" });

    const ref = db.collection("devices").doc(String(deviceId));
    const snap = await ref.get();
    if (!snap.exists) return res.status(400).json({ error: "device not initialized" });

    const stars = snap.data()?.stars ?? 0;
    if (stars <= 0) return res.status(402).json({ error: "no stars", stars });

    await ref.set(
      {
        stars: admin.firestore.FieldValue.increment(-1),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      },
      { merge: true }
    );

    const overallRtp = Math.floor(10 + Math.random() * 84); // 10..93

    await db.collection("scan_logs").add({
      deviceId,
      megaId,
      overallRtp,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
    });

    const after = await ref.get();
    const newStars = after.data()?.stars ?? 0;

    return res.json({ ok: true, overallRtp, stars: newStars });
  } catch (e) {
    return res.status(500).json({ error: "scan failed", detail: String(e?.message || e) });
  }
});

// =======================
// AUTH: REQUEST OTP (send to Telegram user)
// =======================
app.post("/api/auth/request-otp", async (req, res) => {
  try {
    const phone = normalizePhone(req.body?.phone);
    if (!phone) {
      return res.status(400).json({ error: "Invalid phone. Use format +60123456789" });
    }

    const tg = await findTelegramUserByPhone(phone);
    if (!tg) {
      return res.status(404).json({
        error: "Phone not found in Telegram verification.",
        hint: `1) Join group: ${GROUP_LINK}\n\n  // IMPORTANT: ignore commands (so /addcompany works)\n  if (msg.text && msg.text.startsWith("/")) return;\n2) PM bot ${BOT_USERNAME} dan share contact.`,
      });
    }

    const joined = await ensureJoinedGroup(Number(tg.tgUserId));
    if (!joined) {
      return res.status(403).json({
        error: "You must join Telegram group first.",
        link: GROUP_LINK,
      });
    }

    const otp = generateOTP();
    const otpDoc = db.collection("web_otps").doc(phone);
    await otpDoc.set({
      phone,
      tgUserId: String(tg.tgUserId),
      otpHash: hashOTP(otp),
      createdAtMs: nowMs(),
      expiresAtMs: nowMs() + OTP_TTL_MS,
      attempts: 0,
    });

    await bot.sendMessage(
      Number(tg.tgUserId),
      `ðŸ” *TipsMega888 OTP*\n\nOTP anda: *${otp}*\nValid: *3 minit*\n\nJika bukan anda, abaikan mesej ini.`,
      { parse_mode: "Markdown" }
    );

    return res.json({ ok: true, expiresInSec: 180 });
  } catch (e) {
    return res.status(500).json({ error: "request otp failed", detail: String(e?.message || e) });
  }
});

// =======================
// AUTH: REGISTER (verify OTP + create user)
// =======================
app.post("/api/auth/register", async (req, res) => {
  try {
    const phone = normalizePhone(req.body?.phone);
    const username = String(req.body?.username || "").trim();
    const password = String(req.body?.password || "");
    const otp = String(req.body?.otp || "").trim();

    if (!phone) return res.status(400).json({ error: "Invalid phone. Use +E164" });
    if (!username || username.length < 3) return res.status(400).json({ error: "Username terlalu pendek" });
    if (!password || password.length < 6) return res.status(400).json({ error: "Password min 6 char" });
    if (!/^\d{6}$/.test(otp)) return res.status(400).json({ error: "OTP mesti 6 digit" });

    // must exist in tg_users + joined group
    const tg = await findTelegramUserByPhone(phone);
    if (!tg) {
      return res.status(404).json({
        error: "Phone not verified in Telegram yet.",
        hint: `Join group: ${GROUP_LINK}\nPM bot ${BOT_USERNAME} & share contact.`,
      });
    }
    const joined = await ensureJoinedGroup(Number(tg.tgUserId));
    if (!joined) return res.status(403).json({ error: "Join Telegram group first.", link: GROUP_LINK });

    const otpSnap = await db.collection("web_otps").doc(phone).get();
    if (!otpSnap.exists) return res.status(400).json({ error: "OTP not requested or expired." });

    const o = otpSnap.data() || {};
    if ((o.expiresAtMs || 0) < nowMs()) {
      await db.collection("web_otps").doc(phone).delete();
      return res.status(400).json({ error: "OTP expired. Request new OTP." });
    }

    const ok = o.otpHash === hashOTP(otp);
    if (!ok) {
      await db.collection("web_otps").doc(phone).set(
        { attempts: admin.firestore.FieldValue.increment(1) },
        { merge: true }
      );
      return res.status(400).json({ error: "OTP salah." });
    }

    const userRef = db.collection("users").doc(phone);
    const userSnap = await userRef.get();
    if (userSnap.exists && userSnap.data()?.verified) {
      await db.collection("web_otps").doc(phone).delete();
      return res.status(409).json({ error: "Account already exists. Please login." });
    }

    const salt = makeSalt();
    const pass = passwordHash(password, salt);

    // 30 stars bonus (one-time, granted to device after login)
    await userRef.set(
      {
        phone,
        username,
        passSalt: salt,
        passHash: pass,
        verified: true,
        bonusStars: 30,
        bonusGranted: false,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      },
      { merge: true }
    );

    await db.collection("web_otps").doc(phone).delete();

    return res.json({ ok: true, phone, username, bonusStars: 30 });
  } catch (e) {
    return res.status(500).json({ error: "register failed", detail: String(e?.message || e) });
  }
});

// =======================
// AUTH: LOGIN (phone + password)
// =======================
app.post("/api/auth/login", async (req, res) => {
  try {
    const phone = normalizePhone(req.body?.phone);
    const password = String(req.body?.password || "");
    if (!phone) return res.status(400).json({ error: "Invalid phone" });
    if (!password) return res.status(400).json({ error: "Missing password" });

    const userSnap = await db.collection("users").doc(phone).get();
    if (!userSnap.exists) return res.status(404).json({ error: "Account not found" });

    const u = userSnap.data() || {};
    if (!u.verified) return res.status(403).json({ error: "Not verified yet" });

    const salt = String(u.passSalt || "");
    const stored = String(u.passHash || "");
    const computed = passwordHash(password, salt);

    if (!salt || !stored || computed !== stored) {
      return res.status(403).json({ error: "Wrong password" });
    }

    const token = signToken({ phone, ts: nowMs() });
    return res.json({
      ok: true,
      token,
      phone,
      username: u.username || "",
      bonusStars: u.bonusStars ?? 30,
      bonusGranted: !!u.bonusGranted,
    });
  } catch (e) {
    return res.status(500).json({ error: "login failed", detail: String(e?.message || e) });
  }
});



// =======================
// API: GET COMPANIES FOR WEBSITE
// =======================
app.get("/api/companies", async (req, res) => {
  try {
    const snap = await db.collection("companies")
      
      .orderBy("createdAt", "desc")
      .get();

    const list = [];
    snap.forEach(doc => {
      list.push({ id: doc.id, ...doc.data() });
    });

    res.json({ ok: true, companies: list });
  } catch (e) {
    res.status(500).json({ ok: false, error: String(e?.message || e) });
  }
});
// ===== START SERVER =====
const PORT = Number(process.env.PORT || 8080);
app.get('/health',(req,res)=>res.status(200).send('ok'));
app.listen(PORT,'0.0.0.0',()=>console.log('API running on port '+PORT));
